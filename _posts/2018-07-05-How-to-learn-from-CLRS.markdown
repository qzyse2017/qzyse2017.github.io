---
layout: post
title:  "How to learn from CLRS"
date:   2018-07-05 09:26:00 +0800
categories: daily-posts
---
## Why is `Introduction to Algorithms` worth reading?
It is often said that a book is classic and so it is worth reading, but I think being 'classic' is in fact the result but not the reason of the book's great value. Having reading some important parts in CLRS (join the first letter of the authors' last name together), I'm going to write some points about the book's value in my opinion.
1. read it carefully and have a good understanding of the theories, you will have a higher probability to get a good grade for your algorithm course : ) .
2. A good understanding of the discussion on algorithms' correctness and complexity helps you learn to design your own algorithm and optimize it. Although for most programmers and for our most time in working, we don't need to do it ourselves but mastering this crucial skills can make us more valuable over time and changes.
3. if you love math and you love coding, reading this book enables you to communicate deeply with the great masters and you learn more about what you love.
4. the book is well-organized and only requires some basic knowledge on math and programming. Appendixes at the end of the book also offer theories used in the book. There should be little difficulty in reading this book.

## How to learn from it in a proper way
According to your purpose for reading, you may read it in different ways.
1. **you read it to get a good grade** -- You may need to pay more attention to the discussion parts and try your best to learn the basic `techniques` in them.   
There's usually a specific way for some similar problems and you need to just remember the patterns of the problems and their answers in a way like how you memorize your usernames and passwords. Extract the features of the given conditions and the steps of getting to specific deductions using the conditions.
2. **you read it to learn how to write `good` programms** -- you may need to practise a lot with more thinking and trials to figure out the keys to some detailed problems.  
**Choose appropriate data structures.** According to some points like, the data structures' underlying implementations, the safety and time costs of basic operations used in the algorithms, you choose your language and relavant implementations. You may implement the basic data structures yourself, according to some restrictions in your projects. Using some frequenlty used libraries may help accelerating the development but may take more time to shoot the troubles if the troubles are caused by your improper use and the data structures' complicated implementations.  
**Memorize the advantages and disadvantages of alogrithms with similar purposes.** It help you do your work more quick if the problem just needs some common algorithms.  
**Read the algorithms's pseudo code and implement the algorithm yourself in your familiar language.** It helps you get a better understanding of the languages and also helps you learn more techniques in implementing the algorithms elegantly. Implementing an algorithm properly is an important skills for a programmer and by practising and refactoring your code, you can see the influence of practice.  
3. **you read it to solve a problem on algorithms in your work.** -- As the title of the book indicates, this book is just an introduction. If your problems are common, you just need to read relavant chapters and find your solutions however I don't think some common problems will require you to read this book so problems you overcome may more likely be the ones which require you read relavant papers with deeper discussions. At the End of each chapters, the authors summarized the history of the solutions and  provided some relavant classic papers for your to read further.
4. **keep a strong desire to read the book.** Any condition discussed above should provide you with strong desires to read the book. Interests usually don't support you to read such a tome. To complete reading, you need to have a strong curiosity to find answers or you need a strong ambition to become an excellent programmers or engineer. Otherwise, you may just need an exam coming tomorrow. : )
